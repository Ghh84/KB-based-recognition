<?xml version="1.0"?>
<doc>
    <assembly>
        <name>dotNetRDF.Sparql.Core</name>
    </assembly>
    <members>
        <member name="T:VDS.RDF.Collections.ReferenceEqualityComparer`1">
            <summary>
            An equality comparer based purely on Object reference
            </summary>
            <typeparam name="T">Type</typeparam>
        </member>
        <member name="T:VDS.RDF.Query.Aggregation.DistinctShortCircuitAccumulator">
            <summary>
            A decorator around other accumulators which only accumulates distinct values
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregation.BaseShortCircuitExpressionAccumulator">
            <summary>
            An abstract expression based accumulator that supports short circuiting
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregation.IAccumulator">
            <summary>
            Interface for accumulators which are used to caculate aggregates in a streaming fashion
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregation.IAccumulator.Accumulate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Accumulates the solution
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Expression Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Aggregation.IAccumulator.AccumulatedResult">
            <summary>
            Gets the accumulated result
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregation.BaseExpressionAccumulator.Accumulate(VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Accumulates the actual value of evaluating the expression
            </summary>
            <param name="value">Value, will be null if the expression evaluated to an error</param>
        </member>
        <member name="P:VDS.RDF.Query.Aggregation.BaseExpressionAccumulator.AccumulatedResult">
            <summary>
            Gets/Sets the accumulated result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregation.BaseShortCircuitExpressionAccumulator.ShortCircuitResult">
            <summary>
            Gets/Sets the short circuited result assuming evaluation was short circuited
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregation.BaseShortCircuitExpressionAccumulator.ShortCircuit">
            <summary>
            Gets/Sets whether to short circuit evaluation
            </summary>
            <remarks>
            This can be used by derived implementations to indicate that they have already determined the result and accumulating further solutions will not change that result.  This allows evaluation to be sped up considerably in some cases
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Aggregation.BaseShortCircuitExpressionAccumulator.ActualResult">
            <summary>
            Gets/Sets the actual accumulated result assuming evaluation was not short circuited
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregation.SortingAccumulator">
            <summary>
            An accumulator that accumulates a single value decided which value to keep based on a given comparer
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregation.DistinctAccumulator">
            <summary>
            A decorator around other accumulators which only accumulates distinct values
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IBinaryAlgebra">
            <summary>
            Interface for binary algebra operators
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IAlgebra">
            <summary>
            Interface for algebra operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IAlgebra.Accept(VDS.RDF.Query.Algebra.IAlgebraVisitor)">
            <summary>
            Accepts an algebra visitor
            </summary>
            <param name="visitor">Visitor</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IAlgebra.Execute(VDS.RDF.Query.Engine.Algebra.IAlgebraExecutor,VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Executes the algebra
            </summary>
            <param name="executor">Algebra executor</param>
            <param name="context">Execution Context</param>
            <returns></returns>
            <remarks>
            The default implementations provide this visitor pattern style so they simply call back to the appropriate method of the provided algebra executor.  This is therefore primarily intended for use as an extension point, custom algebra operators can be introduced which provide their own execution semantics
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IAlgebra.ToString">
            <summary>
            Gets the string form of the algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IAlgebra.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the string form of the algeba using the given formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IAlgebra.Copy">
            <summary>
            Creates an exact copy of the algebra
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IAlgebra.ProjectedVariables">
            <summary>
            Gets the variables that are projected from this algebra i.e. those visible outside it
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IAlgebra.FixedVariables">
            <summary>
            Gets the variables that are fixed for this algebra i.e. those projected and guaranteed to have a value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IAlgebra.FloatingVariables">
            <summary>
            Gets the variables that are floating for this algebra i.e. those projected and not guaranteed to have a value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IBinaryAlgebra.Copy(VDS.RDF.Query.Algebra.IAlgebra,VDS.RDF.Query.Algebra.IAlgebra)">
            <summary>
            Creates a copy of the operator replacing the inner algebras with the given algebras
            </summary>
            <param name="lhs">LHS Algebra</param>
            <param name="rhs">RHS Algebra</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IBinaryAlgebra.Lhs">
            <summary>
            Gets the LHS algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IBinaryAlgebra.Rhs">
            <summary>
            Gets the RHS algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IUnaryAlgebra">
            <summary>
            Interface for unary algebra operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IUnaryAlgebra.Copy(VDS.RDF.Query.Algebra.IAlgebra)">
            <summary>
            Creates a copy of the operator replacing the inner algebra with the given algebra
            </summary>
            <param name="innerAlgebra">Inner Algebra</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IUnaryAlgebra.InnerAlgebra">
            <summary>
            Gets the inner algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bgp.TriplePatterns">
            <summary>
            Gets the Triple Patterns in the BGP
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.Create(VDS.RDF.Query.Algebra.IAlgebra,VDS.RDF.Query.Algebra.IAlgebra)">
            <summary>
            Creates a join only if necessary i.e. if one side is a join identity returns only the other side
            </summary>
            <param name="lhs">LHS algebra</param>
            <param name="rhs">RHS algebra</param>
            <returns>Algebra</returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.CreateDirect(VDS.RDF.Query.Algebra.IAlgebra,VDS.RDF.Query.Algebra.IAlgebra)">
            <summary>
            Creates a join, unlike <see cref="M:VDS.RDF.Query.Algebra.Join.Create(VDS.RDF.Query.Algebra.IAlgebra,VDS.RDF.Query.Algebra.IAlgebra)"/> does not simplify when one side is the join identity
            </summary>
            <param name="lhs">LHS algebra</param>
            <param name="rhs">RHS algebra</param>
            <returns>Join</returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Transforms.ApplyTransformVisitor">
            <summary>
            An algebra vistor that applies an algebra transform
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IAlgebraVisitor">
            <summary>
            Interface for algebra visitors
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Transforms.ApplyTransformVisitor.Transform(VDS.RDF.Query.Algebra.IAlgebra)">
            <summary>
            Transforms the given algebra
            </summary>
            <param name="algebra">Algebra</param>
            <returns>Transformed algebra</returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Transforms.IAlgebraTransform">
            <summary>
            Interface for algebra transforms
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Compiler.CompilingElementVisitor">
            <summary>
            An element visitor that compiles elements into query algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Elements.IElementVisitor">
            <summary>
            Interface for element visitors
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Compiler.CompilingElementVisitor.Compile(VDS.RDF.Query.Elements.IElement)">
            <summary>
            Compiles the given element into algebra
            </summary>
            <param name="element">Element</param>
            <returns>Compiled Algebra</returns>
        </member>
        <member name="M:VDS.RDF.Query.Compiler.CompilingElementVisitor.CompileInlineData(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Results.IResultRow})">
            <summary>
            Compiles the result rows provided for inline data into the format needed for algebra
            </summary>
            <param name="rows">Rows</param>
            <returns>Inline Data</returns>
        </member>
        <member name="T:VDS.RDF.Query.Compiler.IQueryCompiler">
            <summary>
            Interface for query compilers which take in a query and compile it to the equivalent algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Elements.IElement">
            <summary>
            Interface for query pattern elements
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Elements.IElement.Accept(VDS.RDF.Query.Elements.IElementVisitor)">
            <summary>
            Accepts an element visitor
            </summary>
            <param name="visitor">Element visitor</param>
        </member>
        <member name="P:VDS.RDF.Query.Elements.IElement.Variables">
            <summary>
            Gets all variables mentioned in the element
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Elements.IElement.ProjectedVariables">
            <summary>
            Gets all variables projected and thus visible outside the element
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Elements.TripleBlockElement">
            <summary>
            An element consisting only of simple triple patterns
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Algebra.BaseAlgebraExecutor">
            <summary>
            Abstract implementation of an algebra executor which knows how to execute everything except BGPs and SERVICE clauses
            </summary>
            <remarks>
            This allows derived implementations to provide suitable implementations of BGP execution for their backends and to optionally support federated query
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Algebra.IAlgebraExecutor">
            <summary>
            Interface for algebra executors
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Algebra.IAlgebraExecutor.Execute(VDS.RDF.Query.Algebra.IAlgebra)">
            <summary>
            Executes the algebra using a new default context
            </summary>
            <param name="algebra">Algebra</param>
            <returns>Enumerable of solutions</returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Algebra.IAlgebraExecutor.Execute(VDS.RDF.Query.Algebra.IAlgebra,VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Executes the algebra using the given context (or a new default context if it is null)
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">Execution context</param>
            <returns>Enumberable of solutions</returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Algebra.BaseAlgebraExecutor.EnsureContext(VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Ensures that a valid context is available
            </summary>
            <param name="context">Context</param>
            <returns>A valid non-null context</returns>
        </member>
        <member name="P:VDS.RDF.Query.Engine.Algebra.BaseAlgebraExecutor.JoinStrategySelector">
            <summary>
            Gets the Join Strategy selector that is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.BaseSolution">
            <summary>
            Abstract Base Class for implementations of the <see cref="T:VDS.RDF.Query.Engine.ISolution"/> interface
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.ISolution">
            <summary>
            Interface which represents a possible solution during SPARQL evaluation
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.ISolution.Add(System.String,VDS.RDF.Nodes.INode)">
            <summary>
            Adds a Value for a Variable to the solution
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.ISolution.ContainsVariable(System.String)">
            <summary>
            Checks whether the solution contains a given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.ISolution.IsCompatibleWith(VDS.RDF.Query.Engine.ISolution,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the solution is compatible with a given solution based on the given variables
            </summary>
            <param name="s">Solution</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.ISolution.IsMinusCompatibleWith(VDS.RDF.Query.Engine.ISolution,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the Solution is minus compatible with a given solution based on the given variables
            </summary>
            <param name="s">Solution</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.ISolution.Remove(System.String)">
            <summary>
            Removes a Value for a Variable from the solution
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.ISolution.Join(VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Joins the solution to another solution
            </summary>
            <param name="other">Other solution</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.ISolution.Copy">
            <summary>
            Copies the solution
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.ISolution.Project(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Copies the solution only including the specified variables
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Engine.ISolution.Item(System.String)">
            <summary>
            Retrieves the Value in this solution for the given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns>Either a Node or a null</returns>
        </member>
        <member name="P:VDS.RDF.Query.Engine.ISolution.Values">
            <summary>
            Gets the Values in the solution
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Engine.ISolution.Variables">
            <summary>
            Gets the Variables in the solution
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Engine.ISolution.IsEmpty">
            <summary>
            Gets whether the solution is empty
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.Add(System.String,VDS.RDF.Nodes.INode)">
            <summary>
            Adds a Value for a Variable to the solution
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.ContainsVariable(System.String)">
            <summary>
            Checks whether the solution contains a given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.IsCompatibleWith(VDS.RDF.Query.Engine.ISolution,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the solution is compatible with a given solution based on the given variables
            </summary>
            <param name="s">Solution</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.IsMinusCompatibleWith(VDS.RDF.Query.Engine.ISolution,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the solution is minus compatible with a given solution based on the given variables
            </summary>
            <param name="s">Solution</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.Remove(System.String)">
            <summary>
            Removes a Value for a Variable from the solution
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.Join(VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Joins the solution to another solution
            </summary>
            <param name="other">Other solution</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.Copy">
            <summary>
            Copies the solution
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.Project(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Copies the solution only including the specified variables
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.Equals(VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Gets whether the solution is equal to another solution
            </summary>
            <param name="other">Solution to compare with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.Equals(System.Object)">
            <summary>
            Gets whether the solution is equal to another object
            </summary>
            <param name="obj">Object to compare with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.GetHashCode">
            <summary>
            Gets the Hash Code of the solution
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.BaseSolution.ToString">
            <summary>
            Gets the String representation of the solution
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Engine.BaseSolution.Item(System.String)">
            <summary>
            Retrieves the Value in this solution for the given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns>Either a Node or a null</returns>
        </member>
        <member name="P:VDS.RDF.Query.Engine.BaseSolution.Values">
            <summary>
            Gets the Values in the solution
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Engine.BaseSolution.Variables">
            <summary>
            Gets the Variables in the solution
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Engine.BaseSolution.IsEmpty">
            <summary>
            Gets whether the solution is empty
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Bgps.IBgpExecutor">
            <summary>
            Interface for BGP executors
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Bgps.IBgpExecutor.Match(VDS.RDF.Graphs.Triple,VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Matches a single triple pattern against the active graph as defined by the given context
            </summary>
            <param name="t">Triple pattern</param>
            <param name="context">Execution Context</param>
            <returns>Set for each distinct match</returns>
            <remarks>
            The active graph may be formed of multiple graphs, please see the remarks on <see cref="P:VDS.RDF.Query.Engine.IExecutionContext.ActiveGraph"/> to understand how it should be interpreted
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Bgps.IBgpExecutor.Match(VDS.RDF.Graphs.Triple,VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Matches a single triple pattern with relevant variables from the given input set substituted into it against the active graph as defined by the given context
            </summary>
            <param name="t">Triple pattern</param>
            <param name="input">Input Set</param>
            <param name="context">Execution Context</param>
            <returns>Set for each distinct match</returns>
            <remarks>
            The active graph may be formed of multiple graphs, please see the remarks on <see cref="P:VDS.RDF.Query.Engine.IExecutionContext.ActiveGraph"/> to understand how it should be interpreted
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Solution">
            <summary>
            Represents one possible solution to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.#ctor">
            <summary>
            Creates a new empty solution
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.#ctor(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Creates a new solution which is the Join of the two solutions
            </summary>
            <param name="x">A solution</param>
            <param name="y">A solution</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.#ctor(VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Creates a new solution which is a copy of an existing solution
            </summary>
            <param name="x">solution to copy</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.Add(System.String,VDS.RDF.Nodes.INode)">
            <summary>
            Adds a Value for a Variable to the solution
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.Remove(System.String)">
            <summary>
            Removes a Value for a Variable from the solution
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.ContainsVariable(System.String)">
            <summary>
            Checks whether the solution contains a given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.IsCompatibleWith(VDS.RDF.Query.Engine.ISolution,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the solution is compatible with a given solution based on the given variables
            </summary>
            <param name="s">Solution</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.IsMinusCompatibleWith(VDS.RDF.Query.Engine.ISolution,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the solution is minus compatible with a given solution based on the given variables
            </summary>
            <param name="s">Solution</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.Join(VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Joins the solution to another solution
            </summary>
            <param name="other">Other solution</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.Copy">
            <summary>
            Copies the solution
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.Project(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Copies the solution only including the specified variables
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Solution.Equals(VDS.RDF.Query.Engine.Solution)">
            <summary>
            Gets whether the solution is equal to another solution
            </summary>
            <param name="other">solution to compare with</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Engine.Solution.Item(System.String)">
            <summary>
            Retrieves the Value in this solution for the given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns>Either a Node or a null</returns>
        </member>
        <member name="P:VDS.RDF.Query.Engine.Solution.Variables">
            <summary>
            Gets the Variables in the solution
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Engine.Solution.IsEmpty">
            <summary>
            Gets whether the solution is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Engine.Solution.Values">
            <summary>
            Gets the Values in the solution
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.IExecutionContext">
            <summary>
            Interface for query engine execution context
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.IExecutionContext.PushActiveGraph(VDS.RDF.Nodes.INode)">
            <summary>
            Creates a new execution context with the given Active Graph
            </summary>
            <param name="graphName">Graph Name</param>
            <returns>New execution context</returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.IExecutionContext.CreateExpressionContext">
            <summary>
            Creates a new expression context
            </summary>
            <returns>New expression context</returns>
        </member>
        <member name="P:VDS.RDF.Query.Engine.IExecutionContext.ActiveGraph">
            <summary>
            Gets the current Active Graph
            </summary>
            <remarks>
            This is either an actual graph name of the special value <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> used to indicate that the query default graph is used.  When set to the latter value then the <see cref="P:VDS.RDF.Query.Engine.IExecutionContext.DefaultGraphs"/> property is used to indicate what graphs form the actual query default graph.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Engine.IExecutionContext.DefaultGraphs">
            <summary>
            Gets the defualt graphs for the execution context
            </summary>
            <remarks>
            If this enumerable returns zero results then the query must behave default graph is empty.  If it contains any values then the query must behave as if the default graph is the merge of all the mentioned graphs.  If it contains only the special value <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> then the default graph is the one provided by the underlying dataset.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Engine.IExecutionContext.NamedGraphs">
            <summary>
            Gets the named graphs for the execution context
            </summary>
            <remarks>
            If this enumerable returns zero results then the dataset must be treated as if it contains no named graphs
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Engine.IExecutionContext.EffectiveNow">
            <summary>
            Gets the effective now for the purposes of the execution
            </summary>
            <remarks>
            Must return a constant value throughout the life of the execution, may be late bound i.e. does not need to be initialized until the first time it is accessed
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Engine.IExecutionContext.SharedObjects">
            <summary>
            Gets the dictionary of shared object which can be used to share state for the lifetime of the execution
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Bgps.BaseBgpExecutor">
            <summary>
            Base implementation of a BGP executor which handles determining which graphs the matches should apply to
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Bgps.GraphBgpExecutor">
            <summary>
            A BGP executor over a single <see cref="T:VDS.RDF.Graphs.IGraph"/> instance
            </summary>
            <remarks>
            When used only BGPs that target the default graph identified by the special node <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> will match, any other graph will return empty results
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.EnumerableExtensions.Reduced``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an enumerable which eliminates adjacent duplicates from the given enumerable
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="enumerable">Enumerable</param>
            <returns>Enumerable which removes adjacent duplicates</returns>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Bgps.QuadStoreBgpExecutor">
            <summary>
            A BGP executor over a <see cref="T:VDS.RDF.Graphs.IQuadStore"/>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.IJoinStrategy">
            <summary>
            Interface for join strategies
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Joins.IJoinStrategy.PrepareWorker(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Engine.ISolution})">
            <summary>
            Prepares a new join worker
            </summary>
            <param name="rhs">The enumerable that represents the RHS of the join</param>
            <returns>Join worker</returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Joins.IJoinStrategy.Join(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Joins the two sets together
            </summary>
            <param name="lhs">Left hand side set</param>
            <param name="rhs">Right hand side set</param>
            <returns>Joined set</returns>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.IJoinWorker">
            <summary>
            Interface for join workers
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Joins.IJoinWorker.Find(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Finds all sets that can be joined with the given left hand side set
            </summary>
            <param name="lhs">Left hand side set</param>
            <param name="context"></param>
            <returns>Enumerable of sets from the right hand side</returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Joins.IJoinWorker.CanReuse(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Gets whether this worker can be reused for the given set
            </summary>
            <param name="s">Set</param>
            <param name="context"></param>
            <returns>True if the worker can be reused, false otherwise</returns>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.ReusableJoinWorker">
            <summary>
            Abstract implementation of a reusable join worker
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Joins.ReusableJoinWorker.CanReuse(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Always return true since the work is always reusable
            </summary>
            <param name="s">Left hand side set</param>
            <param name="context"></param>
            <returns>True</returns>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.Strategies.BaseJoinStrategy">
            <summary>
            Abstract join strategy that does a straight join between sets to be joined
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Engine.Joins.Strategies.BaseVariableJoinStrategy.JoinVariables">
            <summary>
            Gets the join variables
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.Strategies.DefaultJoinStrategySelector">
            <summary>
            Default implementation of a join strategy selector
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.Strategies.IJoinStrategySelector">
            <summary>
            Interface for join strategy selectors
            </summary>
            <remarks>
            A join strategy selector embodies the logic for deciding what join strategy should be used depending on the operators involved
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Engine.Joins.Strategies.IJoinStrategySelector.Select(VDS.RDF.Query.Algebra.IAlgebra,VDS.RDF.Query.Algebra.IAlgebra)">
            <summary>
            Selects a join strategy for the given algebra operators
            </summary>
            <param name="lhs">Left hand side operator</param>
            <param name="rhs">Right hand side operator</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.Strategies.WrapperJoinStrategy">
            <summary>
            A decorator for join strategies
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.Strategies.LeftJoinStrategy">
            <summary>
            A decorator which converts other join strategies into left joins
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.Strategies.MaterializedJoinStrategy">
            <summary>
            A wrapper for other join strategies that causes the RHS to be materialized whenever a worker is prepared
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.Joins.Workers.WrapperJoinWorker">
            <summary>
            A decorator for join workers
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.QueryExecutionContext.#ctor">
            <summary>
            Creates a new execution context
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.QueryExecutionContext.#ctor(VDS.RDF.Nodes.INode,System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode},System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a neq execution context
            </summary>
            <param name="activeGraph">Active Graph</param>
            <param name="defaultGraphs">Default Graphs</param>
            <param name="namedGraphs">Named Graphs</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.QueryExecutionContext.#ctor(VDS.RDF.Query.IQuery,System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode},System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new execution context for the given query
            </summary>
            <param name="query">Query</param>
            <param name="datasetDefaultGraphs">Dataset Default Graphs, used only if the query does not specify a dataset</param>
            <param name="datasetNamedGraphs">Dataset Named Graphs, used only if the query does not specify a dataset</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Aggregates.BaseDistinctAggregate">
            <summary>
            Abstract base class for aggregates which have the DISTINCT modifier applied to them
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseNAryExpression">
            <summary>
            Abstract base class for Binary Expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.IExpression">
            <summary>
            Interface for SPARQL Expression Terms that can be used in Expression Trees while evaluating Sparql Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.IExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evalutes a SPARQL Expression for the given binding in a given context
            </summary>
            <param name="set">Set the expression is evaluated on</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.IExpression.Accept(VDS.RDF.Query.Expressions.IExpressionVisitor)">
            <summary>
            
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.IExpression.Copy">
            <summary>
            Makes a copy of the expression
            </summary>
            <returns>Copy of the expression</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.IExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in an expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.IExpression.Functor">
             <summary>
             Gets the Function Name or Operator Symbol - function names may be URIs of Keywords.  If this is not an operator or function then null is returned
             </summary>
            <returns>An operator symbol, function keyword or URI if an operator/function.  Null otherwise</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.IExpression.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.IExpression.IsDeterministic">
            <summary>
            Gets whether an expression is deterministic i.e. guarantees to produce the a specific output when given a specific input
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.IExpression.IsConstant">
            <summary>
            Gets whether the expression represents a constant
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseNAryExpression.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new Base Binary Expression
            </summary>
            <param name="args">Arguments</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseNAryExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseNAryExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseNAryExpression.Arguments">
            <summary>
            The first argument of this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseNAryExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseNAryExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseNAryExpression.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression">
            <summary>
            Class representing Arithmetic Addition expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseBinaryExpression">
            <summary>
            Abstract base class for Binary Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Base Binary Expression
            </summary>
            <param name="leftExpr">Left Expression</param>
            <param name="rightExpr">Right Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.FirstArgument">
            <summary>
            The sub-expressions of this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.SecondArgument">
            <summary>
            The sub-expressions of this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Addition Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression">
            <summary>
            Class representing Arithmetic Division expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Division Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression">
            <summary>
            Class representing Unary Minus expressions (sign of numeric expression is reversed)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseUnaryExpression">
            <summary>
            Abstract base class for Unary Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Base Unary Expression
            </summary>
            <param name="argument">Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.Argument">
            <summary>
            The sub-expression of this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Unary Minus Expression
            </summary>
            <param name="expr">Expression to apply the Minus operator to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression">
            <summary>
            Class representing Arithmetic Multiplication expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Multiplication Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression">
            <summary>
            Class representing Arithmetic Subtraction expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Subtraction Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseAlgebraExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseTernaryExpression">
            <summary>
            Abstract base class for Binary Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseTernaryExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Base Binary Expression
            </summary>
            <param name="firstArg">First Argument</param>
            <param name="secondArg">Second Argument</param>
            <param name="thirdArg">Third Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseTernaryExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseTernaryExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseTernaryExpression.FirstArgument">
            <summary>
            The first argument of this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseTernaryExpression.SecondArgument">
            <summary>
            The second argument of this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseTernaryExpression.ThirdArgument">
            <summary>
            The third argument of this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseTernaryExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseTernaryExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseTernaryExpression.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseNullaryExpression">
            <summary>
            Abstract base class for nullary expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.EqualsExpression">
            <summary>
            Class representing Relational Equality expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Equality Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression">
            <summary>
            Class representing Relational Greater Than Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Greater Than Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression">
            <summary>
            Class representing Relational Greater Than or Equal To Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Greater Than or Equal To Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.LessThanExpression">
            <summary>
            Class representing Relational Less Than Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Less Than Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression">
            <summary>
            Class representing Relational Less Than or Equal To Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Less Than or Equal To Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression">
            <summary>
            Class representing Relational Non-Equality expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Non-Equality Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Conditional.AndExpression">
            <summary>
            Class representing Conditional And expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.AndExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Conditional And Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.AndExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.AndExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Conditional.NotExpression">
            <summary>
            Class representing logical Not Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.NotExpression.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Negation Expression
            </summary>
            <param name="expr">Expression to Negate</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.NotExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.NotExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Conditional.OrExpression">
            <summary>
            Class representing Conditional Or expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.OrExpression.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Conditional Or Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.OrExpression.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.OrExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.ExpressionContext">
            <summary>
            Default implementation of an expression context
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.IExpressionContext">
            <summary>
            Interface to provide context to expression evaluation
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.IExpressionContext.ParentContext">
            <summary>
            Gets the parent execution context
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.IExpressionContext.TemporaryContext">
            <summary>
            Temporary context unique to this expression context
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ExpressionContext.#ctor(VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Creates a new context
            </summary>
            <param name="parentContext">Parent context</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory">
            <summary>
            Expression Factory which generates ARQ Function expressions
            </summary>
            <remarks>
            <para>
            Designed to help provide feature parity with the ARQ query engine contained in Jena
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Factories.IExpressionFactory">
            <summary>
            Interface for implementing SPARQL custom expression factories which turn URI specified functions into SPARQL Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.IExpressionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.IExpression},VDS.RDF.Query.Expressions.IExpression@)">
            <summary>
            Tries to Create a SPARQL Expression for a function with the given URI and set of arguments
            </summary>
            <param name="u">URI of the function</param>
            <param name="args">List of Arguments</param>
            <param name="scalarArguments">Dictionary of Scalar Arguments which are supportable by aggregates when Syntax is set to SPARQL 1.1 Extended</param>
            <param name="expr">Resulting Expression if able to generate</param>
            <returns>True if an expression is generated, false if not</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.IExpressionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the Extension Function URIs that this Factory provides
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.IExpressionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the Extension Aggregate URIs that this Factory provides
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.ArqFunctionsNamespace">
            <summary>
            ARQ Function Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.Max">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.Min">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.Pi">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.E">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.BNode">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.LocalName">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.Namespace">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.Substr">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.Substring">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.StrJoin">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.Sha1Sum">
            <summary>
            Constants for ARQ Miscellaneous functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.Now">
            <summary>
            Constants for ARQ Miscellaneous functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.FunctionUris">
            <summary>
            Array of Extension Function URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.IExpression},VDS.RDF.Query.Expressions.IExpression@)">
            <summary>
            Tries to create an ARQ Function expression if the function Uri correseponds to a supported ARQ Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="scalarArgs">Scalar Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the Extension Function URIs supported by this Factory
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.ArqFunctionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the Extension Aggregate URIs supported by this Factory
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory">
            <summary>
            Expression Factory which generates Leviathan Function expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.LeviathanFunctionsNamespace">
            <summary>
            Leviathan Function Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.MD5Hash">
            <summary>
            Constants for Leviathan String Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Sha256Hash">
            <summary>
            Constants for Leviathan String Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Random">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigSin">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigSinInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigCos">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigCosInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigTan">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigTanInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigSec">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigSecInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigCosec">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigCosecInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigCotan">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TrigCotanInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.DegreesToRadians">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.RadiansToDegrees">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Log">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Ln">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.E">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Ten">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Power">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Square">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Cube">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.SquareRoot">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Root">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Pythagoras">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Cartesian">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Factorial">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Reciprocal">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.All">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Any">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.None">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.NumericMin">
            <summary>
            Constants for Leviathan Numeric Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.NumericMax">
            <summary>
            Constants for Leviathan Numeric Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Mode">
            <summary>
            Constants for other Leviathan Aggregate
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.Median">
            <summary>
            Constants for other Leviathan Aggregate
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.FunctionUris">
            <summary>
            Array of Extension Function URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.AggregateUris">
            <summary>
            Array of Extension Aggregate URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.IExpression},VDS.RDF.Query.Expressions.IExpression@)">
            <summary>
            Tries to create an Leviathan Function expression if the function Uri correseponds to a supported Leviathan Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="scalarArgs">Scalar Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the Extension Function URIs supported by this Factory
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.LeviathanFunctionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the Extension Aggregate URIs supported by this Factory
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Factories.SparqlBuiltInFunctionFactory">
            <summary>
            Expression Factory which generates SPARQL Function expressions
            </summary>
            <remarks>
            This supports the requirement of SPARQL 1.1 that all functions can be accessed via URI as well as by keyword.  This also means that SPARQL 1.1 functions can be used in SPARQL 1.0 mode by using their URIs instead of their keywords and they are then treated simply as extension functions
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace">
            <summary>
            Namespace Uri for SPARQL Built In Functions Namespace
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.SparqlBuiltInFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.IExpression},VDS.RDF.Query.Expressions.IExpression@)">
            <summary>
            Tries to create a SPARQL Function expression if the function Uri correseponds to a supported SPARQL Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="scalarArguments">Scalar Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.SparqlBuiltInFunctionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the URIs of available SPARQL Functions
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.SparqlBuiltInFunctionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the URIs of available SPARQL Aggregates
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Factories.ExpressionFactory">
            <summary>
            Factory Class for generating Expressions for Sparql Extension Functions
            </summary>
            <remarks>
            <para>
            Allows for users of the Library to implement and register Custom Expression Factories which can generate Expressions for their own Extension functions which they wish to use in their SPARQL queries.   Custom factories may be globally scoped by registering them with the <see cref="M:VDS.RDF.Query.Expressions.Factories.ExpressionFactory.AddCustomFactory(VDS.RDF.Query.Expressions.Factories.IExpressionFactory)">AddCustomFactory()</see> method or locally by passing them to the three argument constructor of the <see cref="M:VDS.RDF.Query.Expressions.Factories.ExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.Factories.IExpressionFactory})">CreateExpression()</see> method.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.ExpressionFactory._customFactories">
            <summary>
            List of Custom Expression factories
            </summary>
            <remarks>
            All the standard function libraries (XPath, Leviathan and ARQ) included in dotNetRDF are automatically registered
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.ExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Tries to create an Expression from the given function Uri and list of argument expressions
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">List of Argument Expressions</param>
            <returns></returns>
            <remarks>
            <para>
            Uses only the globally scoped custom expression factories
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.ExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.Factories.IExpressionFactory})">
            <summary>
            Tries to create an Expression from the given function Uri and list of argument expressions
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">List of Argument Expressions</param>
            <param name="factories">Enumeration of locally scoped expression factories to use</param>
            <returns></returns>
            <remarks>
            <para>
            Globally scoped custom expression factories are tried first and then any locally scoped expression factories are used
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.ExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.Factories.IExpressionFactory})">
            <summary>
            Tries to create an Expression from the given function Uri and list of argument expressions
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">List of Argument Expressions</param>
            <param name="scalarArgs">Scalar Arguments</param>
            <param name="factories">Enumeration of locally scoped expression factories to use</param>
            <returns></returns>
            <remarks>
            <para>
            Globally scoped custom expression factories are tried first and then any locally scoped expression factories are used
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.ExpressionFactory.AddCustomFactory(VDS.RDF.Query.Expressions.Factories.IExpressionFactory)">
            <summary>
            Registers a Custom Expression Factory
            </summary>
            <param name="factory">A Custom Expression Factory</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.ExpressionFactory.Factories">
            <summary>
            Gets the Global Custom Expression Factories that are in use
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory">
            <summary>
            Expression Factory which generates XPath Function expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.XPathFunctionsNamespace">
            <summary>
            Namespace Uri for XPath Functions Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Not">
            <summary>
            Constant representing the XPath boolean functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Boolean">
            <summary>
            Constant representing the XPath boolean functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Matches">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Contains">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.StartsWith">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.EndsWith">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.StringLength">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Concat">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Substring">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.NormalizeSpace">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.NormalizeUnicode">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.UpperCase">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.LowerCase">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.EncodeForUri">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.SubstringBefore">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.SubstringAfter">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Replace">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Translate">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Compare">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.StringJoin">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.EscapeHtmlUri">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.True">
            <summary>
            Constants representing the XPath Boolean constructor functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.False">
            <summary>
            Constants representing the XPath Boolean constructor functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Absolute">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Ceiling">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Floor">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.Round">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.RoundHalfToEven">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.YearFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.MonthFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.DayFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.HoursFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.MinutesFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.SecondsFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.TimezoneFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.AdjustDateTimeToTimezone">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.XPathUnicodeNormalizationFormC">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.XPathUnicodeNormalizationFormD">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.XPathUnicodeNormalizationFormKC">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.XPathUnicodeNormalizationFormKD">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.XPathUnicodeNormalizationFormFull">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.AcceptStringArguments">
            <summary>
            Argument Type Validator for validating that a Literal either has no datatype or is a String
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.AcceptIntegerArguments">
            <summary>
            Argument Type Validator for validating that a Literal has an Integer datatype
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.AcceptNumericArguments">
            <summary>
            Argument Type Validator for validating that a Literal has a Numeric datatype
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.IExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.IExpression},VDS.RDF.Query.Expressions.IExpression@)">
            <summary>
            Tries to create an XPath Function expression if the function Uri correseponds to a supported XPath Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="scalarArgs">Scalar Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the Extension Function URIs supported by this Factory
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Factories.XPathFunctionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the Extension Aggregate URIs supported by this Factory
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction">
            <summary>
            Represents the ARQ afn:bnode() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new ARQ afn:bnode() function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.EFunction">
            <summary>
            Represents the ARQ e() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the function
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction">
            <summary>
            Represents the ARQ afn:localname() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new ARQ Local Name function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction">
            <summary>
            Represents the ARQ max() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new ARQ max() function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction">
            <summary>
            Represents the ARQ min() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new ARQ min() function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction">
            <summary>
            Represents the ARQ namespace() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new ARQ Namespace function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction">
            <summary>
            Represents the ARQ afn:now() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns>
            Returns a constant Literal Node which is a Date Time typed Literal
            </returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction">
            <summary>
            Represents the ARQ pi() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.#ctor">
            <summary>
            Creates a new ARQ Pi function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Variables">
            <summary>
            Gets the variables in the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Arguments">
            <summary>
            Gets the arguments of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.Sha1Function">
            <summary>
            Represents the ARQ afn:sha1sum() function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction">
            <summary>
            Abstract base class for Hash Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Creates a new Hash function
            </summary>
            <param name="expr">Expression</param>
            <param name="hash">Hash Algorithm to use</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction.Hash(System.String)">
            <summary>
            Computes Hashes
            </summary>
            <param name="input">Input String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.Sha1Function.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new ARQ SHA1 Sum function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.Sha1Function.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction">
            <summary>
            Represents the ARQ afn:strjoin() function which is a string concatenation function with a separator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new ARQ String Join function
            </summary>
            <param name="sepExpr">Separator Expression</param>
            <param name="expressions">Expressions to concatentate</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction">
            <summary>
            Represents the ARQ afn:substring() function which is a sub-string with Java semantics
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new ARQ substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Expression giving an index at which to start the substring</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new ARQ substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Expression giving an index at which to start the substring</param>
            <param name="endExpr">Expression giving an index at which to end the substring</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.MD5HashFunction">
            <summary>
            Represents the Leviathan lfn:md5hash() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.MD5HashFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan MD5 Hash function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.MD5HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.Sha256HashFunction">
            <summary>
            Represents the Leviathan lfn:sha256hash() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.Sha256HashFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan SHA 256 Hash function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.Sha256HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction">
            <summary>
            Represents the Leviathan lfn:cartesian() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new 2D Cartesian Function
            </summary>
            <param name="x1">Expression for X Coordinate of 1st point</param>
            <param name="y1">Expression for Y Coordinate of 1st point</param>
            <param name="x2">Expression for X Coordinate of 2nd point</param>
            <param name="y2">Expression for Y Coordinate of 2nd point</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new 3D Cartesian Function
            </summary>
            <param name="x1">Expression for X Coordinate of 1st point</param>
            <param name="y1">Expression for Y Coordinate of 1st point</param>
            <param name="z1">Expression for Z Coordiante of 1st point</param>
            <param name="x2">Expression for X Coordinate of 2nd point</param>
            <param name="y2">Expression for Y Coordinate of 2nd point</param>
            <param name="z2">Expression for Z Coordinate of 2nd point</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.CartesianDistance2D(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Internal helper for calculating 2D Cartesian Distance
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.CartesianDistance3D(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Internal helper for calculating 3D Cartesian Distance
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction">
            <summary>
            Represents the Leviathan lfn:cube() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Cube Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction">
            <summary>
            Represents the Leviathan lfn:e() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan E Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction">
            <summary>
            Represents the Leviathan lfn:factorial() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Factorial Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction">
            <summary>
            Represents the Leviathan lfn:log() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Log Function
            </summary>
            <param name="arg">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Log Function
            </summary>
            <param name="arg">Expression</param>
            <param name="logBase">Log Base Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction">
            <summary>
            Represents the Leviathan lfn:ln() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Natural Logarithm Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction">
            <summary>
            Represents the Leviathan lfn:pow() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Power Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction">
            <summary>
            Represents the Leviathan lfn:pythagoras() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Pythagorean Distance Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction">
            <summary>
            Represents the Leviathan lfn:rnd() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.#ctor">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
            <param name="max">Maximum</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
            <param name="min">Minumum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction">
            <summary>
            Represents the Leviathan lfn:reciprocal() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Reciprocal Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction">
            <summary>
            Represents the Leviathan lfn:root() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Root Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction">
            <summary>
            Represents the Leviathan lfn:sq() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Square Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates this expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction">
            <summary>
            Represents the Leviathan lfn:sqrt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Square Root Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction">
            <summary>
            Represents the Leviathan lfn:ten() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Ten Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction">
            <summary>
            Abstract Base Class for Unary Trigonometric Functions in the Leviathan Function Library
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction._func">
            <summary>
            Trigonometric function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Unary Trigonometric Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Func{System.Double,System.Double})">
            <summary>
            Creates a new Unary Trigonometric Function
            </summary>
            <param name="expr">Expression</param>
            <param name="func">Trigonometric Function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction">
            <summary>
            Represents the Leviathan lfn:cosec() or lfn:cosec-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Cosecant Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cosecant Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction">
            <summary>
            Represents the Leviathan lfn:cos() or lfn:cos-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Cosine Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cosine Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction">
            <summary>
            Represents the Leviathan lfn:cot() or lfn:cot-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Cotangent Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cotangent Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction">
            <summary>
            Represents the Leviathan lfn:degrees-to-radians() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Degrees to Radians Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction">
            <summary>
            Represents the Leviathan lfn:radians-to-degrees() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Radians to Degrees Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction">
            <summary>
            Represents the Leviathan lfn:sec() or lfn:sec-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Secant Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Secant Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction">
            <summary>
            Represents the Leviathan lfn:sin() or lfn:sin-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Sine Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Sine Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction">
            <summary>
            Represents the Leviathan lfn:tan() or lfn:tan-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Leviathan Tangent Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Tangent Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrUUIDFunction">
            <summary>
            Represents the SPARQL STRUUID Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUuidFunction">
            <summary>
            Abstract Base Class for functions that generate UUIDs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUuidFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUuidFunction.EvaluateInternal(System.Guid)">
            <summary>
            Method to be implemented by derived classes to implement the actual logic of turning the generated UUID into a RDF term
            </summary>
            <param name="uuid">UUID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUuidFunction.Variables">
            <summary>
            Gets the variables used in the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUuidFunction.Arguments">
            <summary>
            Gets the arguments of the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUuidFunction.CanParallelise">
            <summary>
            Returns whether the function can be parallelised
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrUUIDFunction.EvaluateInternal(System.Guid)">
            <summary>
            Evaluates the function by returning the string form of the given UUID
            </summary>
            <param name="uuid">UUID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrUUIDFunction.Functor">
            <summary>
            Gets the functor for the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.UnknownFunction">
            <summary>
            Represents an Unknown Function that is not supported by dotNetRDF
            </summary>
            <remarks>
            <para>
            This exists as a placeholder class so users may choose to parse Unknown Functions and have them appear in queries even if they cannot be evaluated.  This is useful when you wish to parse a query locally to check syntactic validity before passing it to an external query processor which may understand how to evaluate the function.  Using this placeholder also allows queries containing Unknown Functions to still be formatted properly.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.#ctor(System.Uri)">
            <summary>
            Creates a new Unknown Function that has no Arguments
            </summary>
            <param name="funcUri">Function URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.#ctor(System.Uri,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Unknown Function that has a Single Argument
            </summary>
            <param name="funcUri">Function URI</param>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.#ctor(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new Unknown Function that has multiple Arguments
            </summary>
            <param name="funcUri">Function URI</param>
            <param name="exprs">Argument Expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gives null as the Value since dotNetRDF does not know how to evaluate Unknown Functions
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.UnknownFunction.Functor">
            <summary>
            Gets the Function URI of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction">
            <summary>
            Represents the XPath boolean() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Boolean Function
            </summary>
            <param name="expr">Expression to compute the Effective Boolean Value of</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast">
            <summary>
            Abstract Expression class used as the base class for implementation of XPath Casting Function expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Base XPath Cast Expression
            </summary>
            <param name="expr">Expression to be Cast</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast">
            <summary>
            Class representing an XPath Boolean Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Boolean Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Casts the value of the inner Expression to a Boolean
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast">
            <summary>
            Class representing an XPath Date Time Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Date Time Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Casts the value of the inner Expression to a Date Time
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast">
            <summary>
            Class representing an XPath Decimal Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Decimal Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Casts the Value of the inner Expression to a Decimal
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast">
            <summary>
            Class representing an XPath Double Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Double Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Casts the value of the inner Expression to a Double
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast">
            <summary>
            Class representing an XPath Float Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Float Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Casts the value of the inner Expression to a Float
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast">
            <summary>
            Class representing an XPath Integer Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Integer Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Casts the value of the inner Expression to an Integer
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast">
            <summary>
            Class representing an XPath String Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath String Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Casts the results of the inner expression to a Literal Node typed xsd:string
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction">
            <summary>
            Abstract Base Class for functions which are Unary functions applied to Date Time objects in the XPath function library
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Unary XPath Date Time function
            </summary>
            <param name="expr"></param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Abstract method which derived classes must implement to generate the actual numeric value for the function
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction">
            <summary>
            Represents the XPath day-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Day from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction">
            <summary>
            Represents the XPath hours-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Hours from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction">
            <summary>
            Represents the XPath minutes-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Minutes from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction">
            <summary>
            Represents the XPath month-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Month from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction">
            <summary>
            Represents the XPath seconds-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Seconds from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction">
            <summary>
            Represents the XPath timezone-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Timezone from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Calculates the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction">
            <summary>
            Represents the XPath year-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Year from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction">
            <summary>
            Represents the XPath fn:abs() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Absolute function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction">
            <summary>
            Represents the XPath fn:ceiling() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Ceiling function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction">
            <summary>
            Represents the XPath fn:floor() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Floor function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction">
            <summary>
            Represents the XPath fn:round() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Round function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundHalfToEvenFunction">
            <summary>
            Represents the XPath fn:round() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundHalfToEvenFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath RoundHalfToEven function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundHalfToEvenFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath RoundHalfToEven function
            </summary>
            <param name="expr">Expression</param>
            <param name="precision">Precision</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundHalfToEvenFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundHalfToEvenFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseNAryStringFunction">
            <summary>
            Abstract Base class for XPath NAry String functions, typically these are functions that have an optional second argument and therefore may be unary/binary and thus we have to represent them as NAry functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseNAryStringFunction._argumentTypeValidator">
            <summary>
            Type validation function for the argument
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseNAryStringFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,System.Func{System.Uri,System.Boolean})">
            <summary>
            Creates a new XPath Binary String function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="argExpr">Argument</param>
            <param name="argumentTypeValidator">Type validator for the argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseNAryStringFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseNAryStringFunction.ValueInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseNAryStringFunction.ValueInternal(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction">
            <summary>
            Abstract Base Class for XPath Binary String functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Binary String function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.EvaluateInternal(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction">
            <summary>
            Abstract Base Class for XPath Unary String functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Unary String function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction">
            <summary>
            Represents the XPath fn:compare() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Compare function
            </summary>
            <param name="a">First Comparand</param>
            <param name="b">Second Comparand</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction.EvaluateInternal(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction">
            <summary>
            Represents the XPath fn:concat() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new XPath Concatenation function
            </summary>
            <param name="expressions">Enumeration of expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction">
            <summary>
            Represents the XPath fn:contains() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Contains function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="searchExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction.EvaluateInternal(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction">
            <summary>
            Represents the XPath fn:encode-for-uri() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Encode for URI function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction">
            <summary>
            Represents the XPath fn:ends-with() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Ends With function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="suffixExpr">Suffix Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction.EvaluateInternal(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction">
            <summary>
            Represents the XPath fn:escape-html-uri() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Escape HTML for URI function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction">
            <summary>
            Represents the XPath fn:lower-case() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Lower Case function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction">
            <summary>
            Represents the XPath fn:normalize-space() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Normalize Space function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeUnicodeFunction">
            <summary>
            Represents the XPath fn:normalize-unicode() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeUnicodeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Normalize Unicode function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeUnicodeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Normalize Unicode function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="normalizationFormExpr">Normalization Form</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeUnicodeFunction.ValueInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeUnicodeFunction.ValueInternal(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeUnicodeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction">
            <summary>
            Represents the XPath fn:replace() function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction">
            <summary>
            Represents the XPath fn:replace() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
            <param name="options">Options Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.ConfigureOptions(VDS.RDF.Nodes.INode,System.Boolean)">
            <summary>
            Configures the Options for the Regular Expression
            </summary>
            <param name="n">Node detailing the Options</param>
            <param name="throwErrors">Whether errors should be thrown or suppressed</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
            <param name="options">Options Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction">
            <summary>
            Represents the XPath fn:starts-with() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Starts With function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="prefixExpr">Prefix Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction.EvaluateInternal(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction">
            <summary>
            Represents the XPath fn:string-length() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath String Length function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction">
            <summary>
            Represents the XPath fn:substring-after() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Substring After function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="findExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction.EvaluateInternal(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction">
            <summary>
            Represents the XPath fn:substring-before() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Substring Before function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="findExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction.EvaluateInternal(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction">
            <summary>
            Represents the XPath fn:substring() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
            <param name="lengthExpr">Length</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction">
            <summary>
            Represents the XPath fn:upper-case() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Upper Case function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.IExpressionVisitor">
            <summary>
            Interface for expression visitors
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.ConstantTerm">
            <summary>
            Class for representing constant terms
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.#ctor(VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Creates a new Constant
            </summary>
            <param name="n">Valued Node</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.#ctor(VDS.RDF.Nodes.INode)">
            <summary>
            Creates a new Constant
            </summary>
            <param name="n">Node</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Variables">
            <summary>
            Gets an Empty Enumerable since a Node Term does not use variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Node">
            <summary>
            Node this Term represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.VariableTerm">
            <summary>
            Class representing Variable value expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.VariableTerm.#ctor(System.String)">
            <summary>
            Creates a new Variable Expression
            </summary>
            <param name="name">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.VariableTerm.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.VariableTerm.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.VariableName">
            <summary>
            Gets the Variable Name
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.Variables">
            <summary>
            Gets the enumeration containing the single variable that this expression term represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
            <returns>An operator symbol, function keyword or URI if an operator/function.  Null otherwise</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction">
            <summary>
            Class representing the SPARQL BOUND() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new Bound() function expression
            </summary>
            <param name="varExpr">Variable Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction">
            <summary>
            Represents an EXIST/NOT EXISTS clause used as a Function in an Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.#ctor(VDS.RDF.Query.Algebra.IAlgebra,System.Boolean)">
            <summary>
            Creates a new EXISTS/NOT EXISTS function
            </summary>
            <param name="algebra">Algebra expression</param>
            <param name="mustExist">Whether this is an EXIST</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction">
            <summary>
            Class representing the Sparql IsBlank() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new IsBlank() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction">
            <summary>
            Class representing the Sparql IsIRI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new IsIRI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="solution">Solution</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsUriFunction">
            <summary>
            Class representing the Sparql IsURI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsUriFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new IsURI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsUriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction">
            <summary>
            Class representing the Sparql IsLiteral() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new IsLiteral() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction">
            <summary>
            Represents the SPARQL ISNUMERIC() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL ISNUMERIC() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context"></param>
            <param name="bindingID"></param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction">
            <summary>
            Class representing the Sparql LangMatches() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new LangMatches() function expression
            </summary>
            <param name="term">Expression to obtain the Language of</param>
            <param name="langRange">Expression representing the Language Range to match</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction">
            <summary>
            Class representing the SPARQL REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Regex() function expression
            </summary>
            <param name="text">Text to apply the Regular Expression to</param>
            <param name="pattern">Regular Expression Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Regex() function expression
            </summary>
            <param name="text">Text to apply the Regular Expression to</param>
            <param name="pattern">Regular Expression Pattern</param>
            <param name="options">Regular Expression Options</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.ConfigureOptions(VDS.RDF.Nodes.INode,System.Boolean)">
            <summary>
            Configures the Options for the Regular Expression
            </summary>
            <param name="n">Node detailing the Options</param>
            <param name="throwErrors">Whether errors should be thrown or suppressed</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction">
            <summary>
            Class representing the Sparql SameTerm() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SameTerm() function expression
            </summary>
            <param name="term1">First Term</param>
            <param name="term2">Second Term</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction">
            <summary>
            Class representing the SPARQL CALL() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new COALESCE function with the given expressions as its arguments
            </summary>
            <param name="expressions">Argument expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction">
            <summary>
            Class representing the SPARQL COALESCE() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new COALESCE function with the given expressions as its arguments
            </summary>
            <param name="expressions">Argument expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction">
            <summary>
            Class representing the SPARQL BNODE() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.#ctor">
            <summary>
            Creates a new BNode Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new BNode Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the expression as evaluated in a given Context for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction">
            <summary>
            Class representing the SPARQL IRI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new IRI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction">
            <summary>
            Class representing the Sparql StrDt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new STRDT() function expression
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="dtExpr">Datatype Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction">
            <summary>
            Class representing the Sparql StrDt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new STRLANG() function expression
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="langExpr">Language Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.DayFunction">
            <summary>
            Represents the SPARQL DAY() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.DayFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL DAY() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.DayFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.HoursFunction">
            <summary>
            Represents the SPARQL HOURS() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.HoursFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL HOURS() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.HoursFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MinutesFunction">
            <summary>
            Represents the SPARQL MINUTES() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MinutesFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL MINUTES() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MinutesFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MonthFunction">
            <summary>
            Represents the SPARQL MONTH() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MonthFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL YEAR() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MonthFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.NowFunction">
            <summary>
            Represents the SPARQL NOW() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.NowFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.NowFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.SecondsFunction">
            <summary>
            Represents the SPARQL SECONDS() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.SecondsFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL SECONDS() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.SecondsFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction">
            <summary>
            Represents the SPARQL TIMEZONE() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL TIMEZONE() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Timezone of the Argument Expression as evaluated for the given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction">
            <summary>
            Represents the SPARQL TZ() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL TZ() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Timezone of the Argument Expression as evaluated for the given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.YearFunction">
            <summary>
            Represents the SPARQL YEAR() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.YearFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL YEAR() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.YearFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.MD5HashFunction">
            <summary>
            Represents the SPARQL MD5() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.MD5HashFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new MD5() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.MD5HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha1HashFunction">
            <summary>
            Represents the SPARQL SHA1() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha1HashFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SHA1() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha1HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha256HashFunction">
            <summary>
            Represents the SPARQL SHA256() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha256HashFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SHA256() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha256HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha384HashFunction">
            <summary>
            Represents the SPARQL SHA384() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha384HashFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SHA384() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha384HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha512HashFunction">
            <summary>
            Represents the SPARQL SHA512() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha512HashFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SHA512() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha512HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction">
            <summary>
            Class representing the SPARQL IF function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new IF function
            </summary>
            <param name="condition">Condition</param>
            <param name="ifBranch">Expression to evaluate if condition evaluates to true</param>
            <param name="elseBranch">Expression to evalaute if condition evaluates to false/error</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.Functor">
            <summary>
            Gets the Functor for the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.AbsFunction">
            <summary>
            Represents the SPARQL ABS() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.AbsFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL ABS() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.AbsFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.CeilFunction">
            <summary>
            Represents the SPARQL CEIL() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.CeilFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL CEIL() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.CeilFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.FloorFunction">
            <summary>
            Represents the SPARQL FLOOR() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.FloorFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL FLOOR() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.FloorFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction">
            <summary>
            Represents the SPARQL RAND() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.#ctor">
            <summary>
            Creates a new SPARQL RAND() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Variables">
            <summary>
            Gets the Variables used in this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RoundFunction">
            <summary>
            Represents the SPARQL ROUND() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RoundFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL ROUND() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RoundFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction">
            <summary>
            Abstract base class for SPARQL Functions which operate on Sets
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new SPARQL Set function
            </summary>
            <param name="expr">Expression</param>
            <param name="set">Set</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction">
            <summary>
            Class representing the SPARQL IN set function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new SPARQL IN function
            </summary>
            <param name="expr">Expression</param>
            <param name="set">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction">
            <summary>
            Class representing the SPARQL NOT IN set function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new SPARQL NOT IN function
            </summary>
            <param name="expr">Expression</param>
            <param name="set">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction">
            <summary>
            Abstract Base Class for SPARQL String Testing functions which take two arguments
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Base Binary SPARQL String Function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="argExpr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.ValueInternal(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Abstract method that child classes must implement to 
            </summary>
            <param name="stringLit"></param>
            <param name="argLit"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.IsValidArgumentPair(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether the Arguments are valid
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction">
            <summary>
            Represents the SPARQL CONCAT function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.IExpression})">
            <summary>
            Creates a new SPARQL Concatenation function
            </summary>
            <param name="expressions">Enumeration of expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.Functor">
            <summary>
            Gets the Functor of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction">
            <summary>
            Represents the SPARQL CONTAINS function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new SPARQL CONTAINS function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="searchExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction.ValueInternal(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether the String contains the given Argument
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction">
            <summary>
            Class representing the SPARQL Datatype() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Datatype() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataType11Function">
            <summary>
            Class representing the SPARQL Datatype() function in SPARQL 1.1
            </summary>
            <remarks>
            This is required because the changes to the function in SPARQL 1.1 are not backwards compatible with SPARQL 1.0
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataType11Function.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new DataType function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataType11Function.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction">
            <summary>
            Represents the SPARQL ENCODE_FOR_URI Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Encode for URI function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction">
            <summary>
            Class representing the Sparql Lang() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Lang() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction">
            <summary>
            Represents the SPARQL LCASE Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new LCASE function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Calculates
            </summary>
            <param name="stringLit"></param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction">
            <summary>
            Represents the SPARQL STRAFTER Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new STRAFTER Function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="startsExpr">Starts Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction">
            <summary>
            Represents the SPARQL STRBEFORE function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new STRBEFORE Function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="startsExpr">Starts Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction">
            <summary>
            Represents the SPARQL STRENDS Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new STRENDS() function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="endsExpr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction.ValueInternal(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether the given String Literal ends with the given Argument Literal
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction">
            <summary>
            Class representing the Sparql Str() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new Str() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction">
            <summary>
            Represents the SPARQL STRLEN Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new STRLEN() function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Determines the Length of the given String Literal
            </summary>
            <param name="stringLit">String Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction">
            <summary>
            Represents the SPARQL STRSTARTS Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new STRSTARTS() function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="startsExpr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction.ValueInternal(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether the given String Literal starts with the given Argument Literal
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction">
            <summary>
            Represents the SPARQL SUBSTR Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.#ctor(VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
            <param name="lengthExpr">Length</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.Evaluate(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Expressions.IExpressionContext)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction">
            <summary>
            Represents the SPARQL UCASE Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction.#ctor(VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Creates a new UCASE() function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction.EvaluateInternal(VDS.RDF.Nodes.INode)">
            <summary>
            Converts the given String Literal to upper case
            </summary>
            <param name="stringLit">String Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.UUIDFunction">
            <summary>
            Represents the SPARQL UUID Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.UUIDFunction.EvaluateInternal(System.Guid)">
            <summary>
            Evaluates the function by generating the URN UUID form based on the given UUID
            </summary>
            <param name="uuid">UUID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.UUIDFunction.Functor">
            <summary>
            Gets the functor for the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Transforms.ExprTransformCopy">
            <summary>
            An expression transform that simply copies expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Transforms.ExprTransformMultipleSubstitute">
            <summary>
            An expression transform that substitutes one expression for another
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Transforms.ExprTransformSubstitute">
            <summary>
            An expression transform that substitutes one expression for another
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.BaseOperator">
            <summary>
            Abstract base class for SPARQL Operators which also makes their configuration serializable
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.ISparqlOperator">
            <summary>
            Interface which represents an operator in SPARQL e.g. +
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.ISparqlOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Gets whether the operator can be applied to the given inputs
            </summary>
            <param name="ns">Inputs</param>
            <returns>True if applicable to the given inputs</returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.ISparqlOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator to the given inputs
            </summary>
            <param name="ns">Inputs</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if an error occurs in applying the operator</exception>
        </member>
        <member name="P:VDS.RDF.Query.Operators.ISparqlOperator.Operator">
            <summary>
            Gets the Operator this is an implementation of
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.BaseOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Gets whether the operator can be applied to the given inputs
            </summary>
            <param name="ns">Inputs</param>
            <returns>True if applicable to the given inputs</returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.BaseOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Inputs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.BaseOperator.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the configuration of the operator
            </summary>
            <param name="context">Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Operators.BaseOperator.Operator">
            <summary>
            Gets the operator this implementation represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.BaseDateTimeOperator">
            <summary>
            Abstract base operator for date time operations
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.BaseDateTimeOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Gets whether the arguments are applicable for this operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.BaseTimeSpanOperator">
            <summary>
            Abstract base operator for time span operations
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.BaseTimeSpanOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Gets whether the operator is applicable for the arguments
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.DateTimeAddition">
            <summary>
            Represents the date time addition operator
            </summary>
            <remarks>
            <para>
            Allows for queries to add durations to date times
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.DateTimeAddition.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.DateTime.DateTimeAddition.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.DateTimeSubtraction">
            <summary>
            Represents the date time subtraction operation
            </summary>
            <remarks>
            Allows queries to subtract a duration from a date time
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.DateTimeSubtraction.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.DateTime.DateTimeSubtraction.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.TimeSpanAddition">
            <summary>
            Represents the time span addition operation
            </summary>
            <remarks>
            Allows queries to add time spans together
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.TimeSpanAddition.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.DateTime.TimeSpanAddition.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.TimeSpanSubtraction">
            <summary>
            Represents the time span subtraction operator
            </summary>
            <remarks>
            Allows queries to subtract time spans from each other
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.TimeSpanSubtraction.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.DateTime.TimeSpanSubtraction.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.AdditionOperator">
            <summary>
            Represents the numeric addition operator
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.BaseNumericOperator">
            <summary>
            Abstract base class for numeric operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.BaseNumericOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Operator is applicable if at least one input and all inputs are numeric
            </summary>
            <param name="ns">Inputs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.AdditionOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.Numeric.AdditionOperator.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.DivisionOperator">
            <summary>
            Represents the numeric division operator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.DivisionOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.Numeric.DivisionOperator.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.MultiplicationOperator">
            <summary>
            Represents the numeric multiplication operator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.MultiplicationOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.Numeric.MultiplicationOperator.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.SubtractionOperator">
            <summary>
            Represents the numeric subtraction operator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.SubtractionOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.Numeric.SubtractionOperator.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.SparqlOperators">
            <summary>
            Registry of SPARQL Operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.Init">
            <summary>
            Initializes the Operators registry
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.AddOperator(VDS.RDF.Query.Operators.ISparqlOperator)">
            <summary>
            Registers a new operator
            </summary>
            <param name="op">Operator</param>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.RemoveOperator(VDS.RDF.Query.Operators.ISparqlOperator)">
            <summary>
            Removes the registration of an operator by instance reference
            </summary>
            <param name="op">Operator Reference</param>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.RemoveOperatorByType(VDS.RDF.Query.Operators.ISparqlOperator)">
            <summary>
            Removes the registration of an operator by instance type of the operator
            </summary>
            <param name="op">Operator</param>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.Reset">
            <summary>
            Resets Operator registry to default state
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.IsRegistered(VDS.RDF.Query.Operators.ISparqlOperator)">
            <summary>
            Returns whether the given operator is registered
            </summary>
            <param name="op">Operator</param>
            <returns></returns>
            <remarks>
            Checking is done both by reference and instance type so you can check if an operator is registered even if you don't have the actual reference to the instance that registered
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.GetOperators">
            <summary>
            Gets all registered Operators
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.GetOperators(VDS.RDF.Query.Operators.SparqlOperatorType)">
            <summary>
            Gets all registered operators for the given Operator Type
            </summary>
            <param name="type">Operator Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.TryGetOperator(VDS.RDF.Query.Operators.SparqlOperatorType,VDS.RDF.Query.Operators.ISparqlOperator@,VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Tries to return the operator which applies for the given inputs
            </summary>
            <param name="type">Operator Type</param>
            <param name="op">Operator</param>
            <param name="ns">Inputs</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Operators.SparqlOperatorType">
            <summary>
            Possible SPARQL operand types
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Operators.SparqlOperatorType.Add">
            <summary>
            Addition
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Operators.SparqlOperatorType.Subtract">
            <summary>
            Subtraction
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Operators.SparqlOperatorType.Multiply">
            <summary>
            Multiplication
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Operators.SparqlOperatorType.Divide">
            <summary>
            Division
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Processors.IQueryProcessor">
            <summary>
            Interface for SPARQL Query Processors
            </summary>
            <remarks>
            <para>
            A SPARQL Query Processor is a class that knows how to evaluate SPARQL queries against some data source to which the processor has access
            </para>
            <para>
            The point of this interface is to allow for end users to implement custom query processors or to extend and modify the behaviour of the default Leviathan engine as required.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Processors.IQueryProcessor.Execute(VDS.RDF.Query.IQuery)">
            <summary>
            Executes the given query
            </summary>
            <param name="query">Query</param>
            <returns>Query Result</returns>
        </member>
        <member name="M:VDS.RDF.Query.Processors.IQueryProcessor.Execute(VDS.RDF.Query.IQuery,VDS.RDF.Query.QueryCallback,System.Object)">
            <summary>
            Executes the given query asynchronously
            </summary>
            <param name="query">Query</param>
            <param name="callback">Callback for when the query completes</param>
            <param name="state">State to be passed to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.Processors.AlgebraQueryProcessor.CreateExecutionContext(VDS.RDF.Query.IQuery)">
            <summary>
            Creates an execution context for the query
            </summary>
            <param name="query">Query</param>
            <returns>Execution Context</returns>
        </member>
        <member name="M:VDS.RDF.Query.Processors.AlgebraQueryProcessor.Compile(VDS.RDF.Query.IQuery)">
            <summary>
            Compiles the query into algebra
            </summary>
            <param name="query">Query</param>
            <returns>Algebra</returns>
        </member>
        <member name="M:VDS.RDF.Query.Processors.AlgebraQueryProcessor.Execute(VDS.RDF.Query.Algebra.IAlgebra,VDS.RDF.Query.Engine.IExecutionContext)">
            <summary>
            Executes the algebra
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">Execution Context</param>
            <returns>Query solutions</returns>
        </member>
        <member name="T:VDS.RDF.Query.Paths.TriplePath">
            <summary>
            Represents a triple or a path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.TriplePath.AsTriple">
            <summary>
            Converts into a simple triple if possible
            </summary>
            <returns>Simple triple</returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the path is not a simple triple</exception>
        </member>
        <member name="P:VDS.RDF.Query.Paths.TriplePath.IsTriple">
            <summary>
            Gets whether this is a simple triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.TriplePath.IsPath">
            <summary>
            Gets whether this is a complex path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.AlternativePath">
            <summary>
            Represents Alternative Paths
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.BaseBinaryPath">
            <summary>
            Abstract Base Class for Binary Path operators
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.IPath">
            <summary>
            Represents a Path expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.IPath.ToString">
            <summary>
            Gets the String representation of a Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.IPath.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the string representation of a path using the given formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.IPath.IsTerminal">
            <summary>
            Gets whether the path is a terminal i.e. is not a modifier on another path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.IPath.IsFixedLength">
            <summary>
            Gets whether the path has a fixed length
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseBinaryPath._lhs">
            <summary>
            Parts of the Path
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseBinaryPath._rhs">
            <summary>
            Parts of the Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseBinaryPath.#ctor(VDS.RDF.Query.Paths.IPath,VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new Binary Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseBinaryPath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseBinaryPath.LhsPath">
            <summary>
            Gets the LHS Path component
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseBinaryPath.RhsPath">
            <summary>
            Gets the RHS Path component
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.AlternativePath.#ctor(VDS.RDF.Query.Paths.IPath,VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new Alternative Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="T:VDS.RDF.Query.Paths.BaseUnaryPath">
            <summary>
            Abstract Base Class for Unary Path operators
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseUnaryPath._path">
            <summary>
            Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseUnaryPath.#ctor(VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new Unary Path
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseUnaryPath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseUnaryPath.Path">
            <summary>
            Gets the Inner Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.Cardinality">
            <summary>
            Represents a Cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Cardinality.#ctor(VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new Cardinality Restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Cardinality.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Cardinality.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.FixedCardinality">
            <summary>
            Represents a Fixed Cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.#ctor(VDS.RDF.Query.Paths.IPath,System.Int32)">
            <summary>
            Creates a new Fixed Cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">N</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.FixedCardinality.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.FixedCardinality.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroOrMore">
            <summary>
            Represents a Zero or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrMore.#ctor(VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new Zero or More cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrMore.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrMore.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrMore.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroOrOne">
            <summary>
            Represents a Zero or One cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrOne.#ctor(VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new Zero or One cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrOne.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrOne.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrOne.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.OneOrMore">
            <summary>
            Represents a One or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.OneOrMore.#ctor(VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new One or More cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.OneOrMore.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.OneOrMore.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.OneOrMore.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NOrMore">
            <summary>
            Represents a N or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NOrMore.#ctor(VDS.RDF.Query.Paths.IPath,System.Int32)">
            <summary>
            Creates a new N or More cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Minimum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NOrMore.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NOrMore.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NOrMore.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroToN">
            <summary>
            Represents a Zero to N cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroToN.#ctor(VDS.RDF.Query.Paths.IPath,System.Int32)">
            <summary>
            Creates a new Zero to N cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Maximum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroToN.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroToN.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroToN.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NToM">
            <summary>
            Represents a N to M cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NToM.#ctor(VDS.RDF.Query.Paths.IPath,System.Int32,System.Int32)">
            <summary>
            Creates a new N to M cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Minimum Cardinality</param>
            <param name="m">Maximum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NToM.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NToM.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NToM.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.InversePath">
            <summary>
            Represents an Inverse Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.InversePath.#ctor(VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new Inverse Path
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NegatedSet">
            <summary>
            Represents a Negated Property Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NegatedSet.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Paths.Property},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Paths.Property})">
            <summary>
            Creates a new Negated Property Set
            </summary>
            <param name="properties">Negated Properties</param>
            <param name="inverseProperties">Inverse Negated Properties</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NegatedSet.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NegatedSet.Properties">
            <summary>
            Gets the Negated Properties
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NegatedSet.InverseProperties">
            <summary>
            Gets the Inverse Negated Properties
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.PotentialPath">
            <summary>
            Class representing a potential path used during the evaluation of complex property paths
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.#ctor(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Creates a new Potential Path
            </summary>
            <param name="start">Start Point of the Path</param>
            <param name="current">Current Point on the Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.#ctor(VDS.RDF.Query.Paths.PotentialPath)">
            <summary>
            Creates a new Potential Path which is a copy of an existing Path
            </summary>
            <param name="p">Potentuak Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.GetHashCode">
            <summary>
            Gets the Hash Code for the potential path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.Equals(System.Object)">
            <summary>
            Checks whether the other object is an equivalent potential path
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.ToString">
            <summary>
            Gets the String representation of the path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Start">
            <summary>
            Gets the Start of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Current">
            <summary>
            Gets/Sets the Current Point of the Path - in the case of a complete Path this is the end of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsComplete">
            <summary>
            Gets/Sets whether the Path is complete
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsDeadEnd">
            <summary>
            Gets/Sets whether the Path is a dead-end
            </summary>
            <remarks>
            <para>
            This may be useful information as it can help stop us uneccessarily regenerating partial paths which are dead ends
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsPartial">
            <summary>
            Gets/Sets whether the Path is Partial
            </summary>
            <remarks>
            While this may seem something of a misnomer what this represents is that the path is only part of the overall path so in the case of a sequence path we'll make all incomplete paths from the first part of the sequence as partial so they can't be themselves completed but they can be used to form complete paths
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Length">
            <summary>
            Gets/Sets the Length of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.Property">
            <summary>
            Represents a Predicate which is part of a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.#ctor(VDS.RDF.Nodes.INode)">
            <summary>
            Creates a new Property
            </summary>
            <param name="predicate">Predicate</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Property.Predicate">
            <summary>
            Gets the Predicate this part of the Path represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.SequencePath">
            <summary>
            Represents a standard forwards path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.#ctor(VDS.RDF.Query.Paths.IPath,VDS.RDF.Query.Paths.IPath)">
            <summary>
            Creates a new Sequence Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.ToString(VDS.RDF.Writing.Formatting.IAlgebraFormatter)">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.IQuery">
            <summary>
            Interface for SPARQL Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.IQuery.AddProjectVariable(System.String)">
            <summary>
            Adds a variable to the projections of the query
            </summary>
            <param name="var">Variable to project</param>
        </member>
        <member name="M:VDS.RDF.Query.IQuery.AddProjectExpression(System.String,VDS.RDF.Query.Expressions.IExpression)">
            <summary>
            Adds a project expression to the projections of the query
            </summary>
            <param name="var">Variable to assign value to</param>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.IQuery.RemoveProjection(System.String)">
            <summary>
            Removes the projection for the given variable
            </summary>
            <param name="var">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.IQuery.ClearProjections">
            <summary>
            Removes all projections for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.Namespaces">
            <summary>
            Gets/Sets the namespaces for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.BaseUri">
            <summary>
            Gets/Sets the Base URI for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.DefaultGraphs">
            <summary>
            Gets/Sets the default graphs for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.NamedGraphs">
            <summary>
            Gets/Sets the named graphs for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.QueryType">
            <summary>
            Gets/Sets the Query Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.Limit">
            <summary>
            Gets/Sets the limit for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.Offset">
            <summary>
            Gets/Sets the offset for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.HasLimit">
            <summary>
            Gets whether there is a limit on this query
            </summary>
            <returns>True if the limit is greater than or equal to zero, false otherwise</returns>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.HasOffset">
            <summary>
            Gets whether there is an offset on this query
            </summary>
            <returns>True if the offset is greater than zero, false otherwise</returns>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.SortConditions">
            <summary>
            Gets/Sets the sort conditions that make up the ORDER BY for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.WhereClause">
            <summary>
            Gets/Sets the WHERE clause of the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.HavingConditions">
            <summary>
            Gets/Sets the HAVING conditions of the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.GroupExpressions">
            <summary>
            Gets/Sets the GROUP BY expressions of the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.ValuesClause">
            <summary>
            Gets/Sets the VALUES clause of the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.ConstructTemplate">
            <summary>
            Gets/Sets the CONSTRUCT template for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.Projections">
            <summary>
            Gets/Sets the projections from the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.IQuery.ResultVariables">
            <summary>
            Gets the variables that will be the results of the query
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.QueryCallback">
            <summary>
            Callback for asynchronous query execution
            </summary>
            <param name="result">Query Result</param>
            <param name="state">State</param>
        </member>
        <member name="T:VDS.RDF.Query.Results.AlgebraExecutionResultStream">
            <summary>
            A result stream that allows presenting algebra execution results to the results API
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Results.IResultStream">
            <summary>
            Represents a stream of result rows
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IResultStream.Variables">
            <summary>
            Gets the variables present in the stream
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Results.IMutableResultRow">
            <summary>
            A result row which is mutable
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Results.IResultRow">
            <summary>
            Represents a single result row in a tabular result
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Results.IResultRow.TryGetValue(System.String,VDS.RDF.Nodes.INode@)">
            <summary>
            Tries to get a value for the given variable returning true if a value is present (even if it is null)
            </summary>
            <param name="var">Variable</param>
            <param name="value">Value which may be null</param>
            <returns>True if variable is present, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.Results.IResultRow.TryGetBoundValue(System.String,VDS.RDF.Nodes.INode@)">
            <summary>
            Tries to get a value for the given variable returning true if a value is present and it is not null
            </summary>
            <param name="var">Variable</param>
            <param name="value">Value, guaranteed to be non-null if method returns true</param>
            <returns>True if variable is present and value is non-null, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.Results.IResultRow.HasValue(System.String)">
            <summary>
            Gets whether there is a value present for the given variable (even if the value is null)
            </summary>
            <param name="var">Variable</param>
            <returns>True if variable is present, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.Results.IResultRow.HasBoundValue(System.String)">
            <summary>
            Gets whether there is a value present for the given variable and the value is not null
            </summary>
            <param name="var">Variable</param>
            <returns>True if variable is present and value is non-null, false otherwise</returns>
        </member>
        <member name="P:VDS.RDF.Query.Results.IResultRow.Item(System.String)">
            <summary>
            Gets the value of the specified variable which may be null
            </summary>
            <param name="var">Variable</param>
            <returns>Value which may be null</returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the given variable is not present in this row</exception>
        </member>
        <member name="P:VDS.RDF.Query.Results.IResultRow.Item(System.Int32)">
            <summary>
            Gets the value of the variable in the specified column which may be null
            </summary>
            <param name="index">Column Index</param>
            <returns>Value which may be null</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if the given column index is invalid</exception>
            /// <exception cref="T:VDS.RDF.RdfException">Thrown if the given column index maps to a variable is not present in this row</exception>
        </member>
        <member name="P:VDS.RDF.Query.Results.IResultRow.IsGround">
            <summary>
            Gets whether a row is ground i.e. all values are neither null nor blank nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IResultRow.Variables">
            <summary>
            Gets the variables present in this row
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IResultRow.IsEmpty">
            <summary>
            Gets whether the row is empty
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Results.IMutableResultRow.Set(System.String,VDS.RDF.Nodes.INode)">
            <summary>
            Sets the value of the specified variable
            </summary>
            <param name="var">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="T:VDS.RDF.Query.Results.IMutableTabularResults">
            <summary>
            Represents tabular results that are mutable i.e. may be freely modified by the user
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Results.ITabularResults">
            <summary>
            Represents tabular results
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.ITabularResults.IsStreaming">
            <summary>
            Gets whether the table of results is streaming i.e. single use
            </summary>
            <remarks>
            If this returns true then the enumerator returned by these results is only guaranteed to be valid once and further attempt to obtain an enumerator may result in an error.  If this is false then the results may be enumerated as many times as desired
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Results.ITabularResults.Variables">
            <summary>
            Gets the enumeration of variables present in these results
            </summary>
            <remarks>
            If <see cref="P:VDS.RDF.Query.Results.ITabularResults.IsStreaming"/> returns true then the enumerator returned here is only guaranteed to be valid once and subsequent attempts to obtain and enumerate may result in an error, if this is false then this enumerator may be enumerated as many times as desired.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Results.IMutableTabularResults.AddVariable(System.String)">
            <summary>
            Adds a variable to the results, the variable is added only to the <see cref="P:VDS.RDF.Query.Results.ITabularResults.Variables"/> enumeration and not to individual result rows, use the overload <see cref="M:VDS.RDF.Query.Results.IMutableTabularResults.AddVariable(System.String,VDS.RDF.Nodes.INode)"/> if you wish to add the variable to individual rows
            </summary>
            <param name="var">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Results.IMutableTabularResults.AddVariable(System.String,VDS.RDF.Nodes.INode)">
            <summary>
            Adds a variable to the results adding it to both the <see cref="P:VDS.RDF.Query.Results.ITabularResults.Variables"/> enumeration and the individual rows assigned them the given initial value
            </summary>
            <param name="var">Variable</param>
            <param name="initialValue">Initial value to assign to each row</param>
        </member>
        <member name="T:VDS.RDF.Query.Results.IRandomAccessTabularResults">
            <summary>
            Represents tabular results that may be accessed randomly, this means that they are not streamed and may be accessed in any order
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IRandomAccessTabularResults.Count">
            <summary>
            Gets the number of result rows present
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IRandomAccessTabularResults.Item(System.Int32)">
            <summary>
            Gets the row at the specified row index
            </summary>
            <param name="index">Row Index</param>
            <returns>Result row</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if the row index is invalid</exception>
        </member>
        <member name="T:VDS.RDF.Query.Sorting.ISortCondition">
            <summary>
            Interface for sort conditions
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Sorting.ISortCondition.IsAscending">
            <summary>
            Gets whether this is an ascending sort condition
            </summary>
            <returns>True if an ascending sort condition, false if a descending sort condition</returns>
        </member>
        <member name="P:VDS.RDF.Query.Sorting.ISortCondition.Expression">
            <summary>
            Gets the expression used for sorting
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Engine.SetDistinctnessComparer">
            <summary>
            Comparer for checking whether sets are distinct, check may either be using the entire set or by using only a subset of variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.SetDistinctnessComparer.#ctor">
            <summary>
            Creates a new comparer that compares across all variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Engine.SetDistinctnessComparer.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new comparer that compare only on the specific variables
            </summary>
            <param name="variables">Variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Engine.SetDistinctnessComparer.Equals(VDS.RDF.Query.Engine.ISolution,VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Determines whether the given sets are equal
            </summary>
            <param name="x">First Set</param>
            <param name="y">Second Set</param>
            <returns>True if sets are equal, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.Engine.SetDistinctnessComparer.GetHashCode(VDS.RDF.Query.Engine.ISolution)">
            <summary>
            Gets the hash code for a set
            </summary>
            <param name="obj">Set</param>
            <returns>Hash Code</returns>
        </member>
        <member name="T:VDS.RDF.Query.QueryType">
            <summary>
            Types of SPARQL Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.Ask">
            <summary>
            Ask
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.Construct">
            <summary>
            Constuct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.Describe">
            <summary>
            Describe
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.DescribeAll">
            <summary>
            Describe All
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.Select">
            <summary>
            Select
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.SelectDistinct">
            <summary>
            Select Distinct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.SelectReduced">
            <summary>
            Select Reduced
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.SelectAll">
            <summary>
            Select All
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.SelectAllDistinct">
            <summary>
            Select All Distinct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.QueryType.SelectAllReduced">
            <summary>
            Select All Reduced
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Results.IQueryResult">
            <summary>
            Represents the result of a SPARQL Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IQueryResult.IsTabular">
            <summary>
            Gets whether this result represents a tabular result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IQueryResult.IsGraph">
            <summary>
            Gets whether this result represents a graph result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IQueryResult.IsBoolean">
            <summary>
            Gets whether this result represents a boolean result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IQueryResult.Table">
            <summary>
            Gets the tabular results (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IQueryResult.Graph">
            <summary>
            Gets the graph result (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Results.IQueryResult.Boolean">
            <summary>
            Gets the boolean result (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Results.MutableResultRow">
            <summary>
            Basic implementation of a mutable result row
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Results.ResultRow">
            <summary>
            Basic implementation of a result row
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Results.ResultRow.#ctor">
            <summary>
            Creates a new result row which has no variables and no values
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Results.ResultRow.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new result row that has the given variables but no values
            </summary>
            <param name="variables">Variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Results.ResultRow.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IDictionary{System.String,VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new result row that has the given variables and values
            </summary>
            <param name="variables">Variables</param>
            <param name="values">Values</param>
        </member>
        <member name="M:VDS.RDF.Query.Results.MutableResultRow.#ctor">
            <summary>
            Creates a new result row which has no variables and no values
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Results.MutableResultRow.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new result row that has the given variables but no values
            </summary>
            <param name="variables">Variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Results.MutableResultRow.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IDictionary{System.String,VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new result row that has the given variables and values
            </summary>
            <param name="variables">Variables</param>
            <param name="values">Values</param>
        </member>
        <member name="T:VDS.RDF.Query.Results.QueryResult">
            <summary>
            Basic implementation of query results
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Results.RandomAccessTabularResults">
            <summary>
            Basic implementation of random access tabular results
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Results.RandomAccessTabularResults.#ctor">
            <summary>
            Creates a new random access tabular result that has zero variables and zero result rows
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Results.RandomAccessTabularResults.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new random access tabular result that has the given variables but zero result rows
            </summary>
            <param name="variables"></param>
        </member>
        <member name="M:VDS.RDF.Query.Results.RandomAccessTabularResults.#ctor(System.Int32)">
            <summary>
            Creates a new random access tabular result that consists of zero variables and the given number of empty result rows
            </summary>
            <param name="rows">Number of empty rows</param>
        </member>
        <member name="M:VDS.RDF.Query.Results.RandomAccessTabularResults.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Results.IResultRow})">
            <summary>
            Creates a new random access tabular result that consists of the given variables and rows
            </summary>
            <param name="variables"></param>
            <param name="rows"></param>
        </member>
        <member name="T:VDS.RDF.Query.Results.StreamingTabularResults">
            <summary>
            Represents a set of tabular results that are streamed
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Sorting.SortConditionApplicator">
            <summary>
            Comparer which applies a sequence of sort conditions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Sorting.SparqlNodeComparer">
            <summary>
            Comparer class for implementing the SPARQL semantics for the relational operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlNodeComparer.Compare(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlNodeComparer.Compare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two valued Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlNodeComparer.NumericCompare(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.EffectiveNumericType)">
            <summary>
            Compares two Nodes for Numeric Ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <param name="type">Numeric Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlNodeComparer.NumericCompare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.EffectiveNumericType)">
            <summary>
            Compares two Nodes for Numeric Ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <param name="type">Numeric Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlNodeComparer.DateTimeCompare(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Date Times for Date Time ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlNodeComparer.DateTimeCompare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two Date Times for Date Time ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlNodeComparer.DateCompare(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Dates for Date ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlNodeComparer.DateCompare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two Dates for Date ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Sorting.SparqlOrderingComparer">
            <summary>
            Comparer class for use in SPARQL ORDER BY - implements the Semantics broadly similar to the relational operator but instead of erroring using Node/Lexical ordering where an error would occur it makes an appropriate decision
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlOrderingComparer.Compare(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlOrderingComparer.Compare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Sorting.SparqlOrderingComparer.DateTimeCompare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two Date Times for Date Time ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Templates.ITemplate">
            <summary>
            Interface for templates
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Templates.ITemplate.TemplateQuads">
            <summary>
            Gets the quads that this template represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Templates.ITemplate.TemplateGraphs">
            <summary>
            Gets the names of graphs affected by this template
            </summary>
        </member>
        <member name="P:VDS.RDF.SparqlOptions.QueryExecutionTimeout">
            <summary>
            Gets/Sets the Hard Timeout limit for SPARQL Query Execution (in milliseconds)
            </summary>
            <remarks>
            This is used to stop SPARQL queries running away and never completing execution, it defaults to 3 mins (180,000 milliseconds)
            </remarks>
        </member>
        <member name="P:VDS.RDF.SparqlOptions.QueryOptimisation">
            <summary>
            Gets/Sets whether Query Optimisation should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.SparqlOptions.AlgebraOptimisation">
            <summary>
            Gets/Sets whether Algebra Optimisation should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.SparqlOptions.UnsafeOptimisation">
            <summary>
            Gets/Sets whether some Optimisations considered unsafe can be used
            </summary>
            <remarks>
            <para>
            The notion of unsafe optimisations refers to optimisations that can make significant performance improvements to some types of queries but are disabled normally because they may lead to behaviour which does not strictly align with the SPARQL specification.
            </para>
            <para>
            One example of such an optimisation is an implicit join where the optimiser cannot be sure that the variables involved don't represent literals.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.SparqlOptions.QueryAllowUnknownFunctions">
            <summary>
            Gets/Sets whether functions that can't be parsed into Expressions should be represented by the <see cref="T:VDS.RDF.Query.Expressions.Functions.UnknownFunction">UnknownFunction</see>
            </summary>
            <remarks>When set to false a Parser Error will be thrown if the Function cannot be parsed into an Expression</remarks>
        </member>
        <member name="P:VDS.RDF.SparqlOptions.RigorousEvaluation">
            <summary>
            Gets/Sets whether to use rigorous query evaluation
            </summary>
            <remarks>
            <para>
            Rigorous Query evaluation applies more checks to the triples produced by datasets to ensure they actually match the patterns being scanned.  If the underlying index structures are able to guarantee this then rigorous evaluation may be turned off for faster evaluation which it is by default since our default <see cref="!:TreeIndexedTripleCollection"/> and <see cref="!:TripleCollection"/> implementations will guarantee this.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.SparqlOptions.StrictOperators">
            <summary>
            Gets/Sets whether to use strict operators
            </summary>
            <remarks>
            <para>
            Strict Operators refers to the interpretation of certian operators like + and - in SPARQL expression evaluation.  If enabled then the operators will function only as specified in the SPARQL specification, if disabled (which is the default) then certain extensions (which the SPARQL specification allows an implementation to provide) will be allowed e.g. date time arithmetic.
            </para>
            <para>
            The only time you may want to disable this is if you are developing queries locally which you want to ensure are portable to other systems or when running the SPARQL compliance tests.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.SparqlOptions.UpdateExecutionTimeout">
            <summary>
            Gets/Sets the Hard Timeout limit for SPARQL Update Execution (in milliseconds)
            </summary>
            <remarks>
            This is used to stop SPARQL Updates running away and never completing execution, it defaults to 3 mins (180,000 milliseconds)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsValidQName(System.String,VDS.RDF.Specifications.SparqlQuerySyntax)">
            <summary>
            Checks whether a given QName is valid in Sparql
            </summary>
            <param name="value">QName to check</param>
            <param name="syntax">SPARQL Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsValidVarName(System.String)">
            <summary>
            Checks whether a given Variable Name is valid in Sparql
            </summary>
            <param name="value">Variable Name to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsValidPrefix(System.String)">
            <summary>
            Gets whether a given prefix declaration is valid in SPARQL
            </summary>
            <param name="value">Prefix declaration</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsValidBNode(System.String)">
            <summary>
            Gets whether a given BNode ID is valid
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsPNCharsBase(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS_BASE rule from the Sparql Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsPNCharsU(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS_U rule from the SPARQL Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsPNChars(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS rule from the SPARQL Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsPNLocal(System.Char[],VDS.RDF.Specifications.SparqlQuerySyntax)">
            <summary>
            Checks whether a given String matches the PN_LOCAL rule from the Sparql Specification
            </summary>
            <param name="cs">String as character array</param>
            <param name="syntax">SPARQL Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsPNPrefix(System.Char[])">
            <summary>
            Checks whether a given String matches the PN_PREFIX rule from the SPARQL Specification
            </summary>
            <param name="cs">String as character array</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsPLX(System.Char[],System.Int32,System.Int32@)">
            <summary>
            Checks whether a given String matches the PLX rule from the SPARQL Specification
            </summary>
            <param name="cs">String as character array</param>
            <param name="startIndex">Start Index</param>
            <param name="endIndex">Resulting End Index</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlGrammarHelper.IsHex(System.Char)">
            <summary>
            Gets whether a character is a Hex character
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlQuerySyntax.Sparql_1_0">
            <summary>
            SPARQL 1.0 as defined by the W3C
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlQuerySyntax.Sparql_1_1">
            <summary>
            SPARQL 1.1 as defined by the W3C
            </summary>
        </member>
        <member name="T:VDS.RDF.Specifications.SparqlSpecsHelper">
            <summary>
            Class containing Helper information and methods pertaining to the Sparql Query Language for RDF
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlNamespace">
            <summary>
            Namespace Uri for SPARQL Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlRdfResultsNamespace">
            <summary>
            Namespace Uri for the RDF serialization of a SPARQL Result Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordBase">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordPrefix">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSelect">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordConstruct">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordDescribe">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordAsk">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordOrder">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordOrderBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordLimit">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordOffset">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordDistinct">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordReduced">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordFrom">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordNamed">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordFromNamed">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordWhere">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordGraph">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordOptional">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordUnion">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordFilter">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStr">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordLang">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordLangMatches">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordDataType">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordBound">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSameTerm">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordIsUri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordIsIri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordIsLiteral">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordIsBlank">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordRegex">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordTrue">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordFalse">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordAsc">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordDesc">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordCount">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSum">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordAvg">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMin">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMax">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordGroupConcat">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSample">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordNMin">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordNMax">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMedian">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMode">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordAs">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordGroupBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordGroup">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordHaving">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordExists">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordNot">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordNotExists">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordUnsaid">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordLet">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordBind">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSeparator">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordLength">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStrLang">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStrDt">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordIri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordUri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordBNode">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordIn">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordNotIn">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordCoalesce">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordIf">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordInsert">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordDelete">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordClear">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordLoad">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordData">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordInto">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSilent">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordCreate">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordDrop">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordWith">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordUsing">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordDefault">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordAll">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMinus">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordService">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordBindings">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordValues">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordUndef">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordIsNumeric">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStrLen">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSubStr">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordUCase">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordLCase">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStrStarts">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStrEnds">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStrBefore">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStrAfter">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordReplace">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordContains">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordEncodeForUri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordConcat">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordAbs">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordRound">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordCeil">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordFloor">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordRand">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordNow">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordYear">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMonth">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordDay">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordHours">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMinutes">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSeconds">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordTimezone">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordTz">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMD5">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSha1">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSha256">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSha384">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordSha512">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordAny">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordNone">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordAdd">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordCopy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordMove">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordTo">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordUUID">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordStrUUID">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlKeywordCall">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.NonQueryKeywords">
            <summary>
            Set of SPARQL Keywords that are Non-Query Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.FunctionKeywords">
            <summary>
            Set of SPARQL Keywords that are Function Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.AggregateKeywords">
            <summary>
            Set of SPARQL Keywords that are Aggregate Keywords
            </summary>
            <remarks>
            Unlike <see cref="F:VDS.RDF.Specifications.SparqlSpecsHelper.AggregateFunctionKeywords">AggregateFunctionKeywords[]</see> this includes keywords related to aggregates (like DISTINCT) and those for Leviathan extension aggregates which are not standard SPARQL 1.1 syntax
            </remarks>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.AggregateFunctionKeywords">
            <summary>
            Set of SPARQL Keywords that are built in SPARQL Aggregate Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SupportedCastFunctions">
            <summary>
            Set of IRIs for supported Cast Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlQuery10Keywords">
            <summary>
            Set of Keywords for SPARQL Query 1.0
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlQuery11Keywords">
            <summary>
            Set of additional Keywords for SPARQL Query 1.1
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.UpdateKeywords">
            <summary>
            Set of SPARQL Keywords that are Update Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlUpdate11Keywords">
            <summary>
            Set of Keywords for SPARQL Update 1.1
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlInteger">
            <summary>
            Regular Expression Pattern for Valid Integers in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlDecimal">
            <summary>
            Regular Expression Pattern for Valid Decimals in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.SparqlSpecsHelper.SparqlDouble">
            <summary>
            Regular Expression Pattern for Valid Doubles in Sparql
            </summary>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsQueryKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Query Keyword
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsNonQueryKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Non-Query Keyword
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsFunctionKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Function Verb
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsFunctionKeyword11(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL 1.1 Function Verb
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsAggregateKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Aggregate Keyword (includes keywords related to aggregates like DISTINCT, AS and Leviathan extension aggregate keywords)
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsAggregateFunctionKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Aggregate Function Keyword (only keywords for the SPARQL built-in aggregate functions)
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsUpdateKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Update Keyword
            </summary>
            <param name="keyword"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsValidNumericLiteral(System.String)">
            <summary>
            Checks whether the given value is a valid Numeric Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsInteger(System.String)">
            <summary>
            Checks whether the given value is a valid Integer Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsDecimal(System.String)">
            <summary>
            Checks whether the given value is a valid Decimal Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsFloat(System.String)">
            <summary>
            Checks whether the given value is a valid Float Literal in Sparql
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsDouble(System.String)">
            <summary>
            Checks whether the given value is a valid Double Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.GetNumericTypeFromDataTypeUri(System.Uri)">
            <summary>
            Determines the Sparql Numeric Type for a Literal based on its Data Type Uri
            </summary>
            <param name="dtUri">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.GetNumericTypeFromDataTypeUri(System.String)">
            <summary>
            Determines the Sparql Numeric Type for a Literal based on its Data Type Uri
            </summary>
            <param name="dtUri">Data Type Uri as a String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.UnescapeQName(System.String)">
            <summary>
            Unescapes local name escapes from QNames
            </summary>
            <param name="value">Value to unescape</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.EffectiveBooleanValue(VDS.RDF.Nodes.INode)">
            <summary>
            Calculates the Effective Boolean Value of a given Node according to the Sparql specification
            </summary>
            <param name="n">Node to computer EBV for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.Equality(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Implements Node Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.Inequality(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Implements Node Inequality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.NumericEquality(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.EffectiveNumericType)">
            <summary>
            Implements Numeric Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <param name="type">SPARQL Numeric Tyoe</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.DateTimeEquality(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Implements Date Time Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.DateEquality(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Implements Date Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.TimeSpanEquality(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Implements Time Span Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.ToDecimal(VDS.RDF.Nodes.INode)">
            <summary>
            Converts a Literal Node to a Decimal
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.ToDouble(VDS.RDF.Nodes.INode)">
            <summary>
            Converts a Literal Node to a Double
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.ToFloat(VDS.RDF.Nodes.INode)">
            <summary>
            Converts a Literal Node to a Float
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.ToInteger(VDS.RDF.Nodes.INode)">
            <summary>
            Converts a Literal Node to an Integer
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.ToDateTime(VDS.RDF.Nodes.INode)">
            <summary>
            Converts a Literal Node to a Date Time
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.ToDateTimeOffset(VDS.RDF.Nodes.INode)">
            <summary>
            Converts a Literal Node to a Date Time Offset
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.ToTimeSpan(VDS.RDF.Nodes.INode)">
            <summary>
            Converts a Literal Node to a Time Span
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.SparqlSpecsHelper.IsValidStringArgumentPair(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether the Arguments are valid
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.AlgebraFormatter">
            <summary>
            Node formatter used for formatting algebra as part of <strong>ToString()</strong> implementations for <see cref="T:VDS.RDF.Query.Algebra.IAlgebra"/> implementations
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IAlgebraFormatter">
            <summary>
            Marker interface necessary for algebra formatting
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryException">
            <summary>
            Class for representing errors that occur while querying RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryException.#ctor(System.String)">
            <summary>
            Creates a new RDF Query Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Query Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryTimeoutException">
            <summary>
            Class for representing Timeout errors that occur while querying RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryTimeoutException.#ctor(System.String)">
            <summary>
            Creates a new RDF Query Timeout Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfReasoningException">
            <summary>
            Class for representing Exceptions occurring in RDF reasoners
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfReasoningException.#ctor(System.String)">
            <summary>
            Creates a new RDF Reasoning Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Query.RdfReasoningException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Reasoning Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this exception</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryTerminatedException">
            <summary>
            Class for representing Termination errors
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryTerminatedException.#ctor">
            <summary>
            Creates a new RDF Query Termination Exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryPathFoundException">
            <summary>
            Class for representing Path Found terminations
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryPathFoundException.#ctor">
            <summary>
            Creates a new Path Found exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateException">
            <summary>
            Class of exceptions that may occur when performing SPARQL Updates
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateException.#ctor(System.String)">
            <summary>
            Creates a new RDF Update Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateException.#ctor(System.String,System.Exception)">
            <summary>
            Createa a new RDF Update Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this exception to be thrown</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateTimeoutException">
            <summary>
            Class for representing Timeout errors that occur while updating RDF using SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateTimeoutException.#ctor(System.String)">
            <summary>
            Creates a new SPARQL Update Timeout Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdatePermissionException">
            <summary>
            Class for representing Permissions errors with SPARQL Updates
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdatePermissionException.#ctor(System.String)">
            <summary>
            Creates a new Permission Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdatePermissionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new Permission Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this exception to be thrown</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateMalformedException">
            <summary>
            Class for representing malformed SPARQL Updates
            </summary>
            <remarks>
            This is distinct from a <see cref="T:VDS.RDF.Parsing.RdfParseException">RdfParseException</see> as it is possible for an update to be syntactically valid but semantically malformed
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateMalformedException.#ctor(System.String)">
            <summary>
            Creates a new Malformed Update Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateMalformedException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new Malformed Update Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this exception to be thrown</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolException">
            <summary>
            Class of exceptions that may occur when using the SPARQL Graph Store HTTP Protocol for Graph Management
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolException.#ctor(System.String)">
            <summary>
            Creates a new SPARQL Graph Store HTTP Protocol Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new SPARQL Graph Store HTTP Protocol Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriResolutionException">
            <summary>
            Exception that occurs when a Protocol Processor cannot resolve the URI for the Graph to be acted upon
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriResolutionException.#ctor">
            <summary>
            Creates a new Protocol URI Resolution Exception
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriResolutionException.#ctor(System.String)">
            <summary>
            Creates a new Protocol URI Resolution Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriInvalidException">
            <summary>
            Exception that occurs when a Protocol Processor is provided with a invalid URI for the Graph to be acted upon
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriInvalidException.#ctor">
            <summary>
            Creates a new Protocol Invalid URI Exception
            </summary>
        </member>
        <member name="T:VDS.RDF.ISparqlResultsHandler">
            <summary>
            Interface for Handlers which handle the SPARQL Results produced by parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.StartResults">
            <summary>
            Starts the Handling of Results
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.EndResults(System.Boolean)">
            <summary>
            Ends the Handling of Results
            </summary>
            <param name="ok">Indicates whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.HandleBooleanResult(System.Boolean)">
            <summary>
            Handles a Boolean Result
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.HandleVariable(System.String)">
            <summary>
            Handles a Variable Declaration
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.HandleResult(VDS.RDF.Query.Results.IResultRow)">
            <summary>
            Handles a SPARQL Result
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ISparqlResultsReader">
            <summary>
            Interface for Reader Classes which parser Sparql Result Set syntaxes into Result Set objects
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsReader.Load(VDS.RDF.ISparqlResultsHandler,System.IO.TextReader)">
            <summary>
            Loads a Result Set using a Results Handler from the given Input
            </summary>
            <param name="handler">Results Handler</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="E:VDS.RDF.ISparqlResultsReader.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.ISparqlResultsWriter">
            <summary>
            Interface for Writer classes which serialize Sparql Result Sets into concrete results set syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsWriter.Save(VDS.RDF.Query.Results.IQueryResult,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream
            </summary>
            <param name="result">Query Results to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="E:VDS.RDF.ISparqlResultsWriter.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
        </member>
    </members>
</doc>
